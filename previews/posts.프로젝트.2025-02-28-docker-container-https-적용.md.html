
      <html lang="ko">
      <head>
        <title>docker container nginx 설정, https 적용</title>
        <link rel="canonical" href="http://yuyeol3.github.io/"/>
        <meta charset="utf-8"/>
        <meta name="description" content="현재 사용하고 있는 계정의 aws free-tier가 거의 끝나기도 했고 기존 wigit 서버와 youtube-shortener 서버를 계속 돌리고 있어 요금이 많이 나오기도 했다. 따라서 대안을 찾던 중 youtube-shortener 서버를 Google Cloud Platform을 옮기기로 했다.">
        <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
      </head>
      <body style="display : none;">
        
        <h1>docker container nginx 설정, https 적용</h1>
<p>현재 사용하고 있는 계정의 aws free-tier가 거의 끝나기도 했고 기존 wigit 서버와 youtube-shortener 서버를 계속 돌리고 있어 요금이 많이 나오기도 했다. 따라서 대안을 찾던 중 youtube-shortener 서버를 Google Cloud Platform을 옮기기로 했다. </p>
<h1>1. nginx, certbot 설정하기</h1>
<pre><code class="language-yml"># docker-compose.yml

services:
  database:
    # Dockerfile이 있는 위치
    build: ./database
    image: yuyeol3/youtube-shortener-database
    # 내부에서 개방할 포트 : 외부에서 접근할 포트
    ports:
      - &quot;4000:3306&quot;
    volumes:
      - ./database/mysql_data:/var/lib/mysql
    env_file:
      - ./database/.env

  backend:
    build: ./youtube_shortener
    image: yuyeol3/youtube-shortener-backend
    ports:
      - &quot;3000:3000&quot;
    environment: 
      - DBHOST=database

  ############################
  # NGINX - Reverse Proxy
  ############################
  nginx:
    image: nginx:alpine
    container_name: nginx-reverse-proxy
    depends_on:
      - backend
    ports:
      - &quot;80:80&quot;
      - &quot;443:443&quot;
    volumes:
      # Mount your custom NGINX configuration
      - ./nginx/conf.d:/etc/nginx/conf.d
      # Mount the certificates generated by certbot
      - ./data/certbot/conf:/etc/letsencrypt 
      - ./data/certbot/www:/var/www/certbot
    # You can also use environment variables or a custom default.conf
    # so that NGINX points to your backend container(s).
    # recert를 위한 command
    # command: &quot;/bin/sh -c &#39;while :; do sleep 6h &amp; wait $${!}; nginx -s reload; done &amp; nginx -g \&quot;daemon off;\&quot;&#39;&quot;

  ############################
  # CERTBOT - Let&#39;s Encrypt
  ############################
  certbot:
    image: certbot/certbot
    container_name: certbot
    depends_on:
      - nginx
    volumes:
      - ./certbot/conf:/etc/letsencrypt 
      - ./certbot/www:/var/www/certbot
    # We will run Certbot commands manually (or via a script) to obtain certificates
    # recert를 위한 command
    # entrypoint: &quot;/bin/sh -c &#39;trap exit TERM; while :; do certbot renew; sleep 12h &amp; wait $${!}; done;&#39;&quot;

# volumes:
</code></pre>
<p><code>docker-compose.yml</code>에서 nginx와 certbot을 추가한다. <code>./certbot</code> 에 <code>conf</code> 폴더와 <code>www</code> 폴더를 만든다. <code>./nginx/conf.d/</code>에 <code>default.conf</code>를 만들고 다음과 같이 설정하자.</p>
<pre><code class="language-conf"># ./nginx/conf.d/default.conf
server {
    listen 80;
    listen [::]:80;
    server_name youtube-shortener.duckdns.org;

    # # 정적 파일이 위치한 폴더
    # root /home/ubuntu/youtube_shortener/backend/public;
    # index index.html;

    # location /assets/ {
    #    try_files $uri $uri/ @app;
    # }

    # 요청 URL이 파일이나 디렉터리로 존재하면 정적 서빙,
    # 없으면 @app 위치 블록(Express 서버)로 요청을 넘김

    location /.well-known/acme-challenge/ {
        root /var/www/certbot;
    }


    location / {
        try_files $uri $uri/ @app;
    }

    # 동적 처리가 필요한 경우 Express 서버로 프록시
    location @app {
        proxy_pass http://backend:3000;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    }

    # # SSL 설정 (Certbot에서 관리)
    # ssl_certificate /etc/letsencrypt/live/youtube-shortener.duckdns.org/fullchain.pem;
    # ssl_certificate_key /etc/letsencrypt/live/youtube-shortener.duckdns.org/privkey.pem;
    # include /etc/letsencrypt/options-ssl-nginx.conf;
    # ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem;
}

# server {
#     listen 80;
#     listen [::]:80;
#     server_name youtube-shortener.duckdns.org;

#     # HTTP 요청은 HTTPS로 리다이렉트
#     return 301 https://$host$request_uri;
# }
</code></pre>
<p>아직 https 인증을 받지 못했으므로 인증서 파일이 없다. 따라서 일단 ssl 설정 등은 주석 처리를 통해 비활성화해야 오류가 나지 않는다.</p>
<pre><code class="language-bash">$ sudo docker compose pull
$ sudo docker compose up -d
$ sudo docker ps
</code></pre>
<p>backend와 nginx가 살아있는지 확인한다.</p>
<h1>2. 인증 스크립트를 통해 https 인증받기</h1>
<pre><code class="language-bash">$ curl -L https://raw.githubusercontent.com/wmnnd/nginx-certbot/master/init-letsencrypt.sh &gt; $ init-letsencrypt.sh
$ chmod +x init-letsencrypt.sh
$ nano init-letsencrypt.sh // 도메인, 이메일, 디렉토리 수정
$ sudo ./init-letsencrypt.sh // script를 실행하여 인증서 발급
</code></pre>
<pre><code class="language-bash"># ./init-letsencrypt.sh
#!/bin/bash

if ! [ -x &quot;$(command -v docker-compose)&quot; ]; then
  echo &#39;Error: docker-compose is not installed.&#39; &gt;&amp;2
  exit 1
fi

domains=(domain1 domain2)
rsa_key_size=4096
data_path=&quot;./certbot&quot;
email=&quot;(email)&quot;
staging=0 # Set to 1 if you&#39;re testing your setup to avoid hitting request limits

if [ -d &quot;$data_path&quot; ]; then
  read -p &quot;Existing data found for $domains. Continue and replace existing certificate? (y/N) &quot; decision
  if [ &quot;$decision&quot; != &quot;Y&quot; ] &amp;&amp; [ &quot;$decision&quot; != &quot;y&quot; ]; then
    exit
  fi
fi


if [ ! -e &quot;$data_path/conf/options-ssl-nginx.conf&quot; ] || [ ! -e &quot;$data_path/conf/ssl-dhparams.pem&quot; ]; then
  echo &quot;### Downloading recommended TLS parameters ...&quot;
  mkdir -p &quot;$data_path/conf&quot;
  curl -s https://raw.githubusercontent.com/certbot/certbot/master/certbot-nginx/certbot_nginx/_internal/tls_configs/options-ssl-nginx.conf &gt; &quot;$data_path/conf/options-ssl-nginx.conf&quot;
  curl -s https://raw.githubusercontent.com/certbot/certbot/master/certbot/certbot/ssl-dhparams.pem &gt; &quot;$data_path/conf/ssl-dhparams.pem&quot;
  echo
fi

echo &quot;### Creating dummy certificate for $domains ...&quot;
path=&quot;/etc/letsencrypt/live/$domains&quot;
mkdir -p &quot;$data_path/conf/live/$domains&quot;
docker compose run --rm --entrypoint &quot;\
  openssl req -x509 -nodes -newkey rsa:$rsa_key_size -days 1\
    -keyout &#39;$path/privkey.pem&#39; \
    -out &#39;$path/fullchain.pem&#39; \
    -subj &#39;/CN=localhost&#39;&quot; certbot
echo


echo &quot;### Starting nginx ...&quot;
docker compose up --force-recreate -d nginx
echo

echo &quot;### Deleting dummy certificate for $domains ...&quot;
docker compose run --rm --entrypoint &quot;\
  rm -Rf /etc/letsencrypt/live/$domains &amp;&amp; \
  rm -Rf /etc/letsencrypt/archive/$domains &amp;&amp; \
  rm -Rf /etc/letsencrypt/renewal/$domains.conf&quot; certbot
echo


echo &quot;### Requesting Let&#39;s Encrypt certificate for $domains ...&quot;
#Join $domains to -d args
domain_args=&quot;&quot;
for domain in &quot;${domains[@]}&quot;; do
  domain_args=&quot;$domain_args -d $domain&quot;
done

# Select appropriate email arg
case &quot;$email&quot; in
  &quot;&quot;) email_arg=&quot;--register-unsafely-without-email&quot; ;;
  *) email_arg=&quot;--email $email&quot; ;;
esac

# Enable staging mode if needed
if [ $staging != &quot;0&quot; ]; then staging_arg=&quot;--staging&quot;; fi

docker compose run --rm --entrypoint &quot;\
  certbot certonly --webroot -w /var/www/certbot \
    $staging_arg \
    $email_arg \
    $domain_args \
    --rsa-key-size $rsa_key_size \
    --agree-tos \
    --force-renewal&quot; certbot
echo

echo &quot;### Reloading nginx ...&quot;
docker compose exec nginx nginx -s reload
</code></pre>
<p>나의 경우 docker-compose가 오류나서 docker compose로 명령어를 전부 바꾸어 주었다.</p>
<h1>3. 인증 후 nginx, docker-compose.yml 수정하기</h1>
<pre><code class="language-conf"># ./nginx/conf.d/default.conf
server {
    listen 443 ssl;
    listen [::]:443 ssl;
    server_name youtube-shortener.duckdns.org;

    # 정적 파일이 위치한 폴더
    root /home/ubuntu/youtube_shortener/backend/public;
    index index.html;

    location /assets/ {
        try_files $uri $uri/ @app;
    }

    # 요청 URL이 파일이나 디렉터리로 존재하면 정적 서빙,
    # 없으면 @app 위치 블록(Express 서버)로 요청을 넘김

    location /.well-known/acme-challenge/ {
        root /var/www/certbot;
    }


    location / {
        try_files $uri $uri/ @app;
    }

    # 동적 처리가 필요한 경우 Express 서버로 프록시
    location @app {
        proxy_pass http://backend:3000;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    }

    # SSL 설정 (Certbot에서 관리)
    ssl_certificate /etc/letsencrypt/live/youtube-shortener.duckdns.org/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/youtube-shortener.duckdns.org/privkey.pem;
    include /etc/letsencrypt/options-ssl-nginx.conf;
    ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem;
}

server {
     listen 80;
     listen [::]:80;
     server_name youtube-shortener.duckdns.org;

     # HTTP 요청은 HTTPS로 리다이렉트
     return 301 https://$host$request_uri;
}
</code></pre>
<pre><code class="language-yml"># docker-compose.yml

services:
  database:
    # Dockerfile이 있는 위치
    build: ./database
    image: yuyeol3/youtube-shortener-database
    # 내부에서 개방할 포트 : 외부에서 접근할 포트
    ports:
      - &quot;4000:3306&quot;
    volumes:
      - ./database/mysql_data:/var/lib/mysql
    env_file:
      - ./database/.env

  backend:
    build: ./youtube_shortener
    image: yuyeol3/youtube-shortener-backend
    ports:
      - &quot;3000:3000&quot;
    environment: 
      - DBHOST=database

  ############################
  # NGINX - Reverse Proxy
  ############################
  nginx:
    image: nginx:alpine
    container_name: nginx-reverse-proxy
    depends_on:
      - backend
    ports:
      - &quot;80:80&quot;
      - &quot;443:443&quot;
    volumes:
      # Mount your custom NGINX configuration
      - ./nginx/conf.d:/etc/nginx/conf.d
      # Mount the certificates generated by certbot
      - ./data/certbot/conf:/etc/letsencrypt 
      - ./data/certbot/www:/var/www/certbot
    # You can also use environment variables or a custom default.conf
    # so that NGINX points to your backend container(s).
    # recert를 위한 command
    command: &quot;/bin/sh -c &#39;while :; do sleep 6h &amp; wait $${!}; nginx -s reload; done &amp; nginx -g \&quot;daemon off;\&quot;&#39;&quot;

  ############################
  # CERTBOT - Let&#39;s Encrypt
  ############################
  certbot:
    image: certbot/certbot
    container_name: certbot
    depends_on:
      - nginx
    volumes:
      - ./certbot/conf:/etc/letsencrypt 
      - ./certbot/www:/var/www/certbot
    # We will run Certbot commands manually (or via a script) to obtain certificates
    # recert를 위한 command
    entrypoint: &quot;/bin/sh -c &#39;trap exit TERM; while :; do certbot renew; sleep 12h &amp; wait $${!}; done;&#39;&quot;

# volumes:
</code></pre>
<h1>4. service 등록하기</h1>
<pre><code class="language-service">[Unit]
Description=Youtube Shortener
After=network.target docker.service

[Service]
User=(user name)
Group=(user group)
WorkingDirectory=/home/zerom50/server
ExecStart=/usr/bin/docker compose up --detach
Restart=always
RestartSec=5
Environment=&quot;DOCKER_HOST=unix:///var/run/docker.sock&quot;

[Install]
WantedBy=multi-user.target
</code></pre>
<p>user에게 docker 권한이 없을 수 있으므로 다음과 같이 설정한다.</p>
<pre><code>groups zerom50  # 현재 그룹 확인
sudo usermod -aG docker zerom50 # docker 그룹 추가가
</code></pre>
<pre><code class="language-bash">$ sudo systemctl daemon-reload
$ sudo systemctl enable server
$ sudo systemctl start server
$ sudo systemctl status server
</code></pre>

        <script>
          location.href = "/post-view?href=posts/프로젝트/2025-02-28-docker-container-https-적용.md"
        </script>
      </body>
  